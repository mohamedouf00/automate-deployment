name: Deploy to EC2 with AMI Update and Rolling Deployment

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v2

      # Step 2: Configure AWS credentials for authentication
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 # Adjust this based on your region

      # Step 3: Define all variables and update EC2 instances using SSH
      - name: Define Variables and Update EC2 Using SSH
        run: |
          # Variables
          APP_INSTANCE_TAG="live-test"
          APP_ONE_PATH="/home/ubuntu/automate-deployment"
          APP_TWO_PATH="/home/ubuntu/automate-deployment-1"
          PM2_PROCESS="all" # Adjust this based on your PM2 configuration
          TEMP_FILE_PATH="/tmp/app_versions.txt"
          SSH_USER="ubuntu" # Adjust based on your SSH user

          # Get EC2 instance ID from tag
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$APP_INSTANCE_TAG" --query "Reservations[*].Instances[*].InstanceId" --output text)

          if [ -z "$INSTANCE_ID" ]; then
            echo "No EC2 instance found with the tag $APP_INSTANCE_TAG"
            exit 1
          fi

          # Get the public IP of the EC2 instance
          INSTANCE_PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[*].Instances[*].PublicIpAddress" --output text)

          if [ -z "$INSTANCE_PUBLIC_IP" ]; then
            echo "EC2 instance's public IP not found. Exiting."
            exit 1
          fi

          echo "Updating EC2 instance at IP: $INSTANCE_PUBLIC_IP"

          # Save the private key for SSH usage
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
          chmod 600 private_key.pem
          
          # Run SSH commands to update the projects
          ssh -o StrictHostKeyChecking=no -i private_key.pem $SSH_USER@$INSTANCE_PUBLIC_IP << EOF
            # Initialize fnm (if needed), set up necessary paths to npm and pm2
            export PATH=$PATH:/run/user/1000/fnm_multishells/7830_1729424728206/bin

            # Project One: Checkout the latest release and log version
            cd $APP_ONE_PATH &&
            git fetch --all &&
            git checkout \$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            VERSION_ONE=\$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            echo "Project One Version: \$VERSION_ONE" >> $TEMP_FILE_PATH &&

            # Project Two: Checkout the latest release and log version
            cd $APP_TWO_PATH &&
            git fetch --all &&
            git checkout \$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            VERSION_TWO=\$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            echo "Project Two Version: \$VERSION_TWO" >> $TEMP_FILE_PATH &&

            # Output the versions
            cat $TEMP_FILE_PATH &&
            
            # Install dependencies, build, and restart services for Project One
            cd $APP_ONE_PATH &&
            npm install &&
            pm2 restart $PM2_PROCESS &&
            
            # Install dependencies, build, and restart services for Project Two
            cd $APP_TWO_PATH &&
            npm install &&
            pm2 restart $PM2_PROCESS
          EOF
          echo "Update completed on EC2 instance at IP: $INSTANCE_PUBLIC_IP"

          # Extract the versions from the file for later use in the AMI name
          VERSION_ONE=$(grep "Project One Version" $TEMP_FILE_PATH | awk '{print $4}')
          VERSION_TWO=$(grep "Project Two Version" $TEMP_FILE_PATH | awk '{print $4}')

          echo "VERSION_ONE=$VERSION_ONE" >> $GITHUB_ENV
          echo "VERSION_TWO=$VERSION_TWO" >> $GITHUB_ENV

      # Step 4: Create AMI from the updated EC2 instance
      - name: Create AMI from EC2
        run: |
          echo "Creating AMI from EC2 instance: $INSTANCE_ID"
          # Define the AMI name with project versions and date
          AMI_NAME="App-AMI-$(date +'%Y-%m-%d')-project1-${VERSION_ONE}-project2-${VERSION_TWO}"

          # Create the AMI and capture the AMI ID
          AMI_ID=$(aws ec2 create-image --instance-id "$INSTANCE_ID" --name "$AMI_NAME" --no-reboot --query 'ImageId' --output text)

          # Check if AMI creation was successful
          if [ -z "$AMI_ID" ] || [ "$AMI_ID" == "None" ]; then
            echo "AMI creation failed. Exiting."
            exit 1
          fi
          # If successful, output the AMI ID and store it in GitHub environment variables
          echo "Created AMI: $AMI_ID"
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV

      # Step 5: Update the AWS Launch Template with the new AMI ID
      - name: Update Launch Template with new AMI
        run: |
          LAUNCH_TEMPLATE_NAME="ouf-LT" # Update with your Launch Template name
          TEMPLATE_ID=$(aws ec2 describe-launch-templates --query "LaunchTemplates[?LaunchTemplateName=='$LAUNCH_TEMPLATE_NAME'].LaunchTemplateId" --output text)

          if [ -z "$TEMPLATE_ID" ]; then
            echo "Launch Template not found. Exiting."
            exit 1
          fi

          aws ec2 create-launch-template-version --launch-template-id $TEMPLATE_ID --source-version 1 --launch-template-data '{"ImageId":"'"$AMI_ID"'"}'
          aws ec2 modify-launch-template --launch-template-id $TEMPLATE_ID --default-version 2
          echo "Launch Template updated with new AMI: $AMI_ID"

      # Step 6: Trigger a Rolling Update in the Auto Scaling Group
      - name: Trigger Rolling Update
        run: |
          AUTOSCALING_TAG="ouf-asg" # Update with your Auto Scaling tag key
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?Tags[?Key=='$AUTOSCALING_TAG']].AutoScalingGroupName" --output text)

          if [ -z "$ASG_NAME" ]; then
            echo "Auto Scaling Group not found. Exiting."
            exit 1
          fi

          aws autoscaling start-instance-refresh --auto-scaling-group-name $ASG_NAME --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 300}'
          echo "Triggered Rolling Update for Auto Scaling Group: $ASG_NAME"
