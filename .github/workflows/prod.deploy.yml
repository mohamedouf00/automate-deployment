name: Deploy to EC2 with AMI Update and Rolling Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to Production"
        required: true
        default: "production"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v2

      # Step 2: Configure AWS credentials for authentication
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 # Change this with your region

      # Step 3: Define all variables and update EC2 instances using SSH
      - name: Define Variables and Update EC2 Using SSH
        run: |
          # Variables
          APP_INSTANCE_TAG="live-test"
          APP_ONE_PATH="/home/ubuntu/automate-deployment"
          APP_TWO_PATH="/home/ubuntu/automate-deployment-1"
          PM2_PROCESS="all" # Process name if using PM2
          TEMP_FILE_PATH="/tmp/app_versions.txt"
          SSH_USER="ubuntu" # Change based on the user you connect with
          SSH_KEY_PATH="${{secrets.SSH_PRIVATE_KEY}}" # Using GitHub secrets for the SSH key
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$APP_INSTANCE_TAG" --query "Reservations[*].Instances[*].InstanceId" --output text)
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "No EC2 instance found with the tag $APP_INSTANCE_TAG"
            exit 1
          fi
          
          INSTANCE_PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[*].Instances[*].PublicIpAddress" --output text)
          
          if [ -z "$INSTANCE_PUBLIC_IP" ]; then
            echo "EC2 instance's public IP not found. Exiting."
            exit 1
          fi

          echo "Updating EC2 instance at IP: $INSTANCE_PUBLIC_IP"

          # Save the private key for SSH usage
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          # Run the SSH commands to update the projects
          ssh -o StrictHostKeyChecking=no -i private_key.pem $SSH_USER@$INSTANCE_PUBLIC_IP << 'EOF'
            # Project One: Checkout to the latest release and log version
            cd $APP_ONE_PATH &&
            git fetch --all &&
            git checkout $(git describe --tags $(git rev-list --tags --max-count=1)) &&
            VERSION_ONE=$(git describe --tags $(git rev-list --tags --max-count=1)) &&
            echo "Project One Version: $VERSION_ONE" >> $TEMP_FILE_PATH &&

            # Project Two: Checkout to the latest release and log version
            cd $APP_TWO_PATH &&
            git fetch --all &&
            git checkout $(git describe --tags $(git rev-list --tags --max-count=1)) &&
            VERSION_TWO=$(git describe --tags $(git rev-list --tags --max-count=1)) &&
            echo "Project Two Version: $VERSION_TWO" >> $TEMP_FILE_PATH &&

            # Output the versions
            cat $TEMP_FILE_PATH &&

            # Install dependencies, build, and restart services for Project One
            cd $APP_ONE_PATH &&
            npm install &&
            npm run build &&
            pm2 restart $PM2_PROCESS &&

            # Install dependencies, build, and restart services for Project Two
            cd $APP_TWO_PATH &&
            npm install &&
            npm run build &&
            pm2 restart $PM2_PROCESS
          EOF
          
          echo "Update completed on EC2 instance at IP: $INSTANCE_PUBLIC_IP"

      # Step 4: Create AMI from the updated EC2 instance
      - name: Create AMI from EC2
        run: |
          AMI_NAME="App-AMI-$(date +'%Y-%m-%d')-project1-${VERSION_ONE}-project2-${VERSION_TWO}"

          AMI_ID=$(aws ec2 create-image --instance-id $INSTANCE_ID --name "$AMI_NAME" --no-reboot --output text)
          if [ -z "$AMI_ID" ]; then
            echo "AMI creation failed. Exiting."
            exit 1
          fi
          echo "Created AMI: $AMI_ID"
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV

      # Step 5: Update the AWS Launch Template with the new AMI ID
      - name: Update Launch Template with new AMI
        run: |
          TEMPLATE_ID=$(aws ec2 describe-launch-templates --query "LaunchTemplates[?LaunchTemplateName=='$LAUNCH_TEMPLATE_NAME'].LaunchTemplateId" --output text)

          if [ -z "$TEMPLATE_ID" ]; then
            echo "Launch Template not found. Exiting."
            exit 1
          fi

          aws ec2 create-launch-template-version --launch-template-id $TEMPLATE_ID --source-version 1 --launch-template-data '{"ImageId":"'"$AMI_ID"'"}'
          aws ec2 modify-launch-template --launch-template-id $TEMPLATE_ID --default-version 2
          echo "Launch Template updated with new AMI: $AMI_ID"

      # Step 6: Trigger a Rolling Update in the Auto Scaling Group
      - name: Trigger Rolling Update
        run: |
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?Tags[?Key=='$AUTOSCALING_TAG']].AutoScalingGroupName" --output text)

          if [ -z "$ASG_NAME" ]; then
            echo "Auto Scaling Group not found. Exiting."
            exit 1
          fi

          aws autoscaling start-instance-refresh --auto-scaling-group-name $ASG_NAME --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 300}'
          echo "Triggered Rolling Update for Auto Scaling Group: $ASG_NAME"
