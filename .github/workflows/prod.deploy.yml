name: Deploy to EC2 with AMI Update and Rolling Deployment

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v2

      # Step 2: Configure AWS credentials for authentication
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 # Adjust this based on your region

      # Step 3: Debug Secrets (Optional for Debugging)
      - name: Debug Secrets
        run: |
          echo "Debugging Secrets..."
          if [ -z "${{ secrets.INSTANCE_ID }}" ]; then
            echo "INSTANCE_ID secret is not set!"
          else
            echo "INSTANCE_ID: ${{ secrets.INSTANCE_ID }}"
          fi
          if [ -z "${{ secrets.INSTANCE_PUBLIC_IP }}" ]; then
            echo "INSTANCE_PUBLIC_IP secret is not set!"
          else
            echo "INSTANCE_PUBLIC_IP: ${{ secrets.INSTANCE_PUBLIC_IP }}"
          fi

      # Step 4: Define all variables and Update EC2 Using SSH
      - name: Define Variables and Update EC2 Using SSH
        run: |
          set -e  # Exit on any error
          echo "Setting up variables and updating EC2 instance via SSH..."
          APP_INSTANCE_TAG="live-test"
          APP_ONE_PATH="/home/ubuntu/automate-deployment"
          APP_TWO_PATH="/home/ubuntu/automate-deployment-1"
          PM2_PROCESS="all" # Adjust this based on your PM2 configuration
          TEMP_FILE_PATH="/tmp/app_versions.txt"
          SSH_USER="ubuntu" # Adjust based on your SSH user
          INSTANCE_ID="${{ secrets.INSTANCE_ID }}"
          INSTANCE_PUBLIC_IP="${{ secrets.INSTANCE_PUBLIC_IP }}"

          echo "INSTANCE_ID: $INSTANCE_ID"
          echo "INSTANCE_PUBLIC_IP: $INSTANCE_PUBLIC_IP"

          if [ -z "$INSTANCE_ID" ]; then
            echo "No EC2 instance ID found. Exiting."
            exit 1
          fi
          
          echo "EC2 instance found with ID: $INSTANCE_ID"

          if [ -z "$INSTANCE_PUBLIC_IP" ]; then
            echo "EC2 instance's public IP not found. Exiting."
            exit 1
          fi

          echo "Updating EC2 instance at IP: $INSTANCE_PUBLIC_IP"

          # Save the private key for SSH usage
          echo "Saving SSH private key..."
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          # Run SSH commands to update the projects and fetch the versions
          echo "Connecting to EC2 via SSH to update projects and retrieve versions..."
          ssh -o StrictHostKeyChecking=no -i private_key.pem $SSH_USER@$INSTANCE_PUBLIC_IP << EOF
            set -e  # Exit on any error

            echo "Creating or clearing the temp file for storing versions..."
            > $TEMP_FILE_PATH

            echo "Checking out latest version of Project One..."
            cd $APP_ONE_PATH
            git fetch --all
            LATEST_TAG_ONE=\$(git describe --tags \$(git rev-list --tags --max-count=1))
            if [ -z "\$LATEST_TAG_ONE" ]; then
              echo "Error: Failed to retrieve latest tag for Project One."
              exit 1
            fi
            echo "Project One Version: \$LATEST_TAG_ONE" >> $TEMP_FILE_PATH

            echo "Checking out latest version of Project Two..."
            cd $APP_TWO_PATH
            git fetch --all
            LATEST_TAG_TWO=\$(git describe --tags \$(git rev-list --tags --max-count=1))
            if [ -z "\$LATEST_TAG_TWO" ]; then
              echo "Error: Failed to retrieve latest tag for Project Two."
              exit 1
            fi
            echo "Project Two Version: \$LATEST_TAG_TWO" >> $TEMP_FILE_PATH

            echo "Outputting the versions..."
            cat $TEMP_FILE_PATH

            echo "Installing dependencies and restarting services for Project One..."
            cd $APP_ONE_PATH
            npm install
            pm2 restart $PM2_PROCESS

            echo "Installing dependencies and restarting services for Project Two..."
            cd $APP_TWO_PATH
            npm install
            pm2 restart $PM2_PROCESS
          EOF

          echo "Reading project versions..."
          if ! [ -f $TEMP_FILE_PATH ]; then
            echo "Error: $TEMP_FILE_PATH does not exist."
            exit 1
          fi

          VERSION_ONE=$(grep "Project One Version" $TEMP_FILE_PATH | awk '{print $4}')
          VERSION_TWO=$(grep "Project Two Version" $TEMP_FILE_PATH | awk '{print $4}')

          # Check if versions were successfully retrieved
          if [ -z "$VERSION_ONE" ]; then
            echo "Error: Failed to retrieve VERSION_ONE. Exiting."
            exit 1
          fi

          if [ -z "$VERSION_TWO" ]; then
            echo "Error: Failed to retrieve VERSION_TWO. Exiting."
            exit 1
          fi

          echo "VERSION_ONE=$VERSION_ONE"
          echo "VERSION_TWO=$VERSION_TWO"
          echo "VERSION_ONE=$VERSION_ONE" >> $GITHUB_ENV
          echo "VERSION_TWO=$VERSION_TWO" >> $GITHUB_ENV


      # Step 5: Create AMI from the updated EC2 instance
      - name: Create AMI from EC2
        run: |
          set -e  # Exit on any error
          echo "Creating AMI from EC2 instance..."
          INSTANCE_ID="${{ secrets.INSTANCE_ID }}"
          VERSION_ONE="${{ env.VERSION_ONE }}"
          VERSION_TWO="${{ env.VERSION_TWO }}"

          echo "INSTANCE_ID: $INSTANCE_ID"
          echo "VERSION_ONE: $VERSION_ONE"
          echo "VERSION_TWO: $VERSION_TWO"

          AMI_NAME="App-AMI-$(date +'%Y-%m-%d')-project1-${VERSION_ONE}-project2-${VERSION_TWO}"

          echo "AMI Name: $AMI_NAME"

          AMI_ID=$(aws ec2 create-image --instance-id "$INSTANCE_ID" --name "$AMI_NAME" --no-reboot --query 'ImageId' --output text)

          if [ -z "$AMI_ID" ] || [ "$AMI_ID" == "None" ]; then
            echo "AMI creation failed. Exiting."
            exit 1
          fi

          echo "Created AMI: $AMI_ID"
          echo "AMI_ID=$AMI_ID"
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV

      # Step 6: Update the AWS Launch Template with the new AMI ID
      - name: Update Launch Template with new AMI
        run: |
          set -e  # Exit on any error
          echo "Updating AWS Launch Template with new AMI..."
          LAUNCH_TEMPLATE_NAME="ouf-LT"
          TEMPLATE_ID=$(aws ec2 describe-launch-templates --query "LaunchTemplates[?LaunchTemplateName=='$LAUNCH_TEMPLATE_NAME'].LaunchTemplateId" --output text)
          if [ -z "$TEMPLATE_ID" ]; then
            echo "Launch Template not found. Exiting."
            exit 1
          fi
          echo "Launch Template ID: $TEMPLATE_ID"

          AMI_ID="${{ env.AMI_ID }}"
          if [ -z "$AMI_ID" ]; then
            echo "AMI_ID is not set. Exiting."
            exit 1
          fi
          echo "AMI_ID: $AMI_ID"

          AMI_STATE=$(aws ec2 describe-images --image-ids $AMI_ID --query 'Images[0].State' --output text)
          echo "AMI State: $AMI_STATE"
          while [ "$AMI_STATE" == "pending" ]; do
            echo "AMI is still pending. Waiting for it to be available..."
            sleep 10
            AMI_STATE=$(aws ec2 describe-images --image-ids $AMI_ID --query 'Images[0].State' --output text)
            echo "AMI State: $AMI_STATE"
          done

          echo "AMI is available. Creating new Launch Template version..."
          aws ec2 create-launch-template-version --launch-template-id $TEMPLATE_ID --source-version 1 --launch-template-data '{"ImageId":"'"$AMI_ID"'"}'
          aws ec2 modify-launch-template --launch-template-id $TEMPLATE_ID --default-version 2
          aws ec2 create-tags --resources $AMI_ID --tags Key=Name,Value=$AMI_NAME
          echo "Launch Template updated with new AMI: $AMI_ID"

      # Step 7: Trigger a Rolling Update in the Auto Scaling Group
      - name: Trigger Rolling Update
        run: |
          set -e  # Exit on any error
          echo "Triggering Rolling Update in Auto Scaling Group..."
          AUTOSCALING_TAG="ouf-asg"
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?Tags[?Key=='name' && Value=='$AUTOSCALING_TAG']].AutoScalingGroupName" --output text)
                    if [ -z "$ASG_NAME" ]; then
            echo "Auto Scaling Group not found. Exiting."
            exit 1
          fi
          echo "Auto Scaling Group Name: $ASG_NAME"

          echo "Starting instance refresh..."
          aws autoscaling start-instance-refresh --auto-scaling-group-name $ASG_NAME --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 300}'
          echo "Triggered Rolling Update for Auto Scaling Group: $ASG_NAME"

