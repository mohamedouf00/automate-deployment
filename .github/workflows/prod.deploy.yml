name: Deploy to EC2 with AMI Update and Rolling Deployment

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v2

      # Step 2: Configure AWS credentials for authentication
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 # Adjust this based on your region

      # Step 3: Debug Secrets (Optional)
      - name: Debug Secrets
        run: |
          echo "INSTANCE_ID: ${{ secrets.INSTANCE_ID }}"
          echo "INSTANCE_PUBLIC_IP: ${{ secrets.INSTANCE_PUBLIC_IP }}"

      # Step 4: Define all variables and update EC2 instances using SSH
      - name: Define Variables and Update EC2 Using SSH
        run: |
          set -e  # Exit on any error
          # Variables
          APP_INSTANCE_TAG="live-test"
          APP_ONE_PATH="/home/ubuntu/automate-deployment"
          APP_TWO_PATH="/home/ubuntu/automate-deployment-1"
          PM2_PROCESS="all" # Adjust this based on your PM2 configuration
          TEMP_FILE_PATH="/tmp/app_versions.txt"
          SSH_USER="ubuntu" # Adjust based on your SSH user
          INSTANCE_ID=${{ secrets.INSTANCE_ID }}
          INSTANCE_PUBLIC_IP=${{ secrets.INSTANCE_PUBLIC_IP }}
          echo "INSTANCE_ID=${{ secrets.INSTANCE_ID }}"
          echo "INSTANCE_PUBLIC_IP=${{ secrets.INSTANCE_PUBLIC_IP }}"

          if [ -z "$INSTANCE_ID" ]; then
            echo "No EC2 instance found with the tag $APP_INSTANCE_TAG"
            exit 1
          fi
          
          echo "EC2 instance found with ID: $INSTANCE_ID"

          if [ -z "$INSTANCE_PUBLIC_IP" ]; then
            echo "EC2 instance's public IP not found. Exiting."
            exit 1
          fi

          echo "Updating EC2 instance at IP: $INSTANCE_PUBLIC_IP"

          # Save the private key for SSH usage
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
          chmod 600 private_key.pem

          # Run SSH commands to update the projects
          ssh -o StrictHostKeyChecking=no -i private_key.pem $SSH_USER@$INSTANCE_PUBLIC_IP << EOF
            export PATH=$PATH:/run/user/1000/fnm_multishells/7830_1729424728206/bin

            # Project One: Checkout the latest release and log version
            cd $APP_ONE_PATH &&
            git fetch --all &&
            git checkout \$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            VERSION_ONE=\$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            echo "Project One Version: \$VERSION_ONE" >> $TEMP_FILE_PATH &&

            # Project Two: Checkout the latest release and log version
            cd $APP_TWO_PATH &&
            git fetch --all &&
            git checkout \$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            VERSION_TWO=\$(git describe --tags \$(git rev-list --tags --max-count=1)) &&
            echo "Project Two Version: \$VERSION_TWO" >> $TEMP_FILE_PATH &&

            # Output the versions
            cat $TEMP_FILE_PATH &&

            # Install dependencies, build, and restart services for Project One
            cd $APP_ONE_PATH &&
            npm install &&
            pm2 restart $PM2_PROCESS &&

            # Install dependencies, build, and restart services for Project Two
            cd $APP_TWO_PATH &&
            npm install &&
            pm2 restart $PM2_PROCESS
          EOF

          echo "Update completed on EC2 instance at IP: $INSTANCE_PUBLIC_IP"

          # Extract the versions from the file for later use in the AMI name
          VERSION_ONE=$(grep "Project One Version" $TEMP_FILE_PATH | awk '{print $4}')
          VERSION_TWO=$(grep "Project Two Version" $TEMP_FILE_PATH | awk '{print $4}')

          echo "VERSION_ONE=$VERSION_ONE" >> $GITHUB_ENV
          echo "VERSION_TWO=$VERSION_TWO" >> $GITHUB_ENV

      # Step 5: Create AMI from the updated EC2 instance
      - name: Create AMI from EC2
        run: |
          set -e  # Exit on any error
          echo "Creating AMI from EC2 instance: $INSTANCE_ID"

          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: INSTANCE_ID is not set. Exiting."
            exit 1
          fi

          AMI_NAME="App-AMI-$(date +'%Y-%m-%d')-project1-${{ env.VERSION_ONE }}-project2-${{ env.VERSION_TWO }}"

          AMI_ID=$(aws ec2 create-image --instance-id "$INSTANCE_ID" --name "$AMI_NAME" --no-reboot --query 'ImageId' --output text)

          if [ -z "$AMI_ID" ] || [ "$AMI_ID" == "None" ]; then
            echo "AMI creation failed. Exiting."
            exit 1
          fi

          echo "Created AMI: $AMI_ID"
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV

      # Step 6: Update the AWS Launch Template with the new AMI ID
      - name: Update Launch Template with new AMI
        run: |
          set -e  # Exit on any error
          LAUNCH_TEMPLATE_NAME="ouf-LT"
          TEMPLATE_ID=$(aws ec2 describe-launch-templates --query "LaunchTemplates[?LaunchTemplateName=='$LAUNCH_TEMPLATE_NAME'].LaunchTemplateId" --output text)
          if [ -z "$TEMPLATE_ID" ]; then
            echo "Launch Template not found. Exiting."
            exit 1
          fi
          aws ec2 create-launch-template-version --launch-template-id $TEMPLATE_ID --source-version 1 --launch-template-data '{"ImageId":"'"${{ env.AMI_ID }}"'"}'
          aws ec2 modify-launch-template --launch-template-id $TEMPLATE_ID  --default-version 2
          echo "Launch Template updated with new AMI: $AMI_ID"

      # Step 7: Trigger a Rolling Update in the Auto Scaling Group
      - name: Trigger Rolling Update
        run: |
          set -e  # Exit on any error
          AUTOSCALING_TAG="ouf-asg"
          ASG_NAME=$(
            aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?Tags[?Key=='name' && Value=='$AUTOSCALING_TAG']].AutoScalingGroupName" --output text
          )
          if [ -z "$ASG_NAME" ]; then
            echo "Auto Scaling Group not found. Exiting."
            exit 1
          fi
          aws autoscaling start-instance-refresh --auto-scaling-group-name $ASG_NAME --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 300}'
          echo "Triggered Rolling Update for Auto Scaling Group: $ASG_NAME"
